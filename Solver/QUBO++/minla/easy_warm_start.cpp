// docker run --rm --platform=linux/amd64 -v "$(pwd)":/workspace -w /workspace/minla qbpp-linux make easy_warm_start

#include "qbpp.hpp"
#include "qbpp_easy_solver.hpp"
#include "qbpp_exhaustive_solver.hpp"

#include <filesystem>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <iostream>
#include <chrono>
#include <cmath>

using namespace std;

// Function to calculate penalty parameter for general graph
size_t param_for_general_graph(size_t n, size_t m) {
    double naive = m * (n - 1);
    double complete = n * (n - 1) * (n + 1) / 6.0;
    double k = std::ceil(n + 0.5 - 0.5 * std::sqrt(8.0 * m + 1));
    double f = (n - k) * (n - k + 1) / 2.0;
    double edges_method = (m - f) * (k - 1) + (n - k) * (n*n + (n + 3) * k - 2*k*k - 1) / 6.0;
    return static_cast<size_t>(std::min({naive, complete, edges_method}));
    // return static_cast<size_t>(n);
}

int main()
{
    namespace fs = std::filesystem;
    std::string graph_dir = "../../"; // Adjust path as needed
    std::vector<std::string> graph_files;
    
    // Structure to store results
    struct Result {
        std::string filename;
        size_t vertices;
        size_t edges;
        size_t penalty_param;
        bool feasible;
        double energy;
        double time_taken;
        std::vector<int> arrangement;
    };
    std::vector<Result> all_results;
    
    for (const auto& entry : fs::directory_iterator(graph_dir)) {
        if (entry.is_regular_file()) {
            std::string fname = entry.path().filename().string();
            if (fname.find("graph_") == 0 && fname.find(".out") != std::string::npos) {
                graph_files.push_back(entry.path().string());
            }
        }
    }

    for (const auto& graph_file : graph_files) {
        std::ifstream fin(graph_file);
        if (!fin) continue;
        size_t n, m;
        fin >> n >> m;
        std::vector<std::pair<int,int>> edges;
        for (size_t i = 0; i < m; ++i) {
            int u, v;
            fin >> u >> v;
            edges.emplace_back(u, v);
        }
        std::cout << "Processing " << graph_file << ": " << n << " vertices, " << m << " edges\n";
        
        auto start_time = std::chrono::high_resolution_clock::now();

        // Try reading spectral ordering warm-start (generated by baselines.py)
        // Expected file: same basename with suffix .spectral.txt, one line of space-separated vertex ids
        std::vector<int> spectral_order;
        try {
            fs::path gpath(graph_file);
            fs::path spectral_path = gpath;
            spectral_path.replace_extension(".spectral.txt");
            std::ifstream sf(spectral_path);
            if (sf) {
                std::string line;
                if (std::getline(sf, line)) {
                    std::istringstream iss(line);
                    int v;
                    while (iss >> v) spectral_order.push_back(v);
                }
                std::cout << "  Loaded spectral warm-start: " << spectral_path.filename().string() 
                          << " (" << spectral_order.size() << " entries)" << std::endl;
            } else {
                std::cout << "  No spectral warm-start found (" << spectral_path.filename().string() << ")" << std::endl;
            }
        } catch (...) {
            std::cout << "  Warning: failed to read spectral warm-start file." << std::endl;
        }


        const size_t u = n;
        const size_t k = n;

        // Calculate penalty parameter using the formula
        const size_t penalty_params = param_for_general_graph(n, m);
        std::cout << "  Calculated penalty parameter: " << penalty_params << std::endl;

        auto x = qbpp::var("x", u, k);

        auto penalty_rows = qbpp::expr();

        for (size_t i = 0; i < u; i++)
        {
            for (size_t j = 0; j < k - 1; j++)
            {
                penalty_rows += (1 - x[i][j]) * (x[i][j + 1]);
            }
        }

        auto penalty_cols = qbpp::expr();

        for (size_t j = 0; j < k; j++)
        {
            auto terms = qbpp::expr();
            for (size_t i = 0; i < u; i++)
            {
                terms += x[i][j];
            }
            penalty_cols += (terms - (u - j)) * (terms - (u - j));
        }

        auto penalty = penalty_rows + penalty_cols;
        auto constraint = penalty_params * penalty;

        auto objective = qbpp::expr();

        for (const auto &e : edges)
        {
            int u = e.first;
            int v = e.second;

            auto abs_diff = qbpp::expr();
            for (size_t j = 0; j < k; j++)
            {
                abs_diff += x[u][j] + x[v][j] - 2 * x[u][j] * x[v][j];
            }

            objective += abs_diff;
        }

        auto qubo = objective + penalty_params * constraint;

        // Simplify before creating solver/solution
        qubo.simplify_as_binary();
        cout << qubo << endl;

        qbpp::easy_solver::EasySolver solver(qubo);
        solver.time_limit(120.0);
        // solver.enable_default_callback(); 

        // Build initial solution from spectral order if available
        auto initial_sol = qbpp::Sol(qubo);

        for (size_t i = 0; i < spectral_order.size(); ++i) {
            size_t v = spectral_order[i];
            cout << v << " ";
            for (size_t j = 0; j < k; ++j) {
                cout << (j < v ? 1 : 0);
                if (j < v) initial_sol.set(x[i][j], true);
                else initial_sol.set(x[i][j], false);
            }
            cout << endl;
        }

        // cout << initial_sol << endl;
        auto sol = solver.search(initial_sol);
        
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);

        std::vector<int> label(u, -1);
        for (size_t i = 0; i < u; ++i) {
            label[i] = qbpp::toInt(sum(sol.get(x[i])));
        }

        // check if label is a permutation of 0 to n-1
        std::vector<bool> seen(u, false);
        bool feasible = true;
        for (size_t i = 0; i < u; ++i) {
            int val = label[i] - 1;
            if (val < 0 || val >= static_cast<int>(u) || seen[val]) {
                feasible = false;
                break;
            }
            seen[val] = true;
        }
        std::cout << "\n  Feasibility: " << (feasible ? "Feasible" : "Infeasible") << std::endl;

                
        // Store result
        Result result;
        result.filename = fs::path(graph_file).filename().string();
        result.vertices = n;
        result.edges = m;
        result.energy = sol.energy();
        result.time_taken = duration.count();
        result.penalty_param = penalty_params;
        result.feasible = feasible;
        all_results.push_back(result);
        
    }
    
    // Save results to file
    std::ofstream results_file("minla_results.csv");
    results_file << "Filename,Vertices,Edges,Penalty_Param,Energy,Time_ms\n";
    
    for (const auto& result : all_results) {
        
        results_file << result.filename << "," << result.vertices << "," << result.edges 
                    << "," << result.penalty_param << "," << result.energy << "," << result.time_taken;
        
        results_file << "\n";
    }
    results_file.close();
    
    std::cout << "\n=== SUMMARY ===\n";
    std::cout << "Processed " << all_results.size() << " graphs\n";
    std::cout << "Results saved to minla_results.csv\n";
}